# Пояснения

## Архитектура
В приложении была реализована чистая архитектура. 
Многослойная архитектура устанавливает ограничения на взаимодействие между слоями. 
Все слои взаимодействуют между собой строго через интерфейсы что
* способствуют созданию модульного кода
* обеспечивает гибкость
* упрощает навигацию по проекту и способствует лучшей организации кода.

Методы для работы с сущностями Founder и для работы с сущностями Client разделены на соответствующие классы, такой подход гарантирует масштабируемость. При необходимости методы для взаимодействия со сущностями можно расширять.

## Слой Entities
Сущности `Client` и `Founder` дополнены полями `Id`. Хотя это и нарушает "правила" реляционных баз данных, где вместо поля `Id` следовало бы использовать `TIN` (ИНН) как уникальный идентификатор, на практике многие компании отказываются от такого подхода. Вместо этого вводят дополнительное навигационное поле, что упрощает работу, например, при использовании сторонних библиотек. Также стоит отметить, что поле `Id` проще в управлении и менее подвержено изменениям.

## Слой UseCases
На этом слое располагается бизнес логика приложения а также происходит основная валидация и логирование данных.

Не использовал DTO (Data Transmition Object) в виду отсутствия нежелательный для передачи полей у классов

## Слой Persistence
Слой `Persistence` изолирует код доступа к базе данных а также всю логику, связанную с работой с базой данных, в отдельном проекте, это гарантирует, что все обращения к базе данных находятся в одном месте, что значительно упрощает тестирование, рефакторинг и настройку производительности. 

Реализован паттерн Репозиторий, благодаря чему, при необходимости, можно использовать любую базу данных:
 >мы работаем не с методами конкретного класса, а с методами интерфейса IRepository. И только в конструкторе контроллера мы определяем непосредственный тип репозитория: `db = new SQLBookRepository();`. Таким образом, мы практически избавляемся от зависимости к определенному типу подключения.


## Валидация
Реализовал несколько методов для валидации
* Валидация через атрибуты
* Отдельный сервис (статические классы) для валидации данных. Не использовал сторонние библиотеки (на производстве так бы делать не стал, но в рамках тестового задание считаю это приемлемым)

## Логирование
В приложении реализован  пользовательский сервис логирования, который использует библиотеку `NLog.Extensions.Logging`. Вся логика работы с NLog размещена в слое `Services`, в классе `LoggerManager`. 
Такой подход предоставляет возможность осуществлять логирования на разных слоях приложения при этом не нарушая концепцию чистой архитектуры
Благодаря использованию интерфейса `ILoggerManager`, сохраняется гибкость для легкого перехода на другую библиотеку логирования, при необходимости
